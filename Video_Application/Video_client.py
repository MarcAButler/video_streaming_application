# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'Video_application.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

import sys, socket, cv2, pickle, imutils, struct, queue, pyshine, json, numpy
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtGui import *
from PyQt5.QtWidgets import *
from PyQt5.QtCore import *

################################################################################
# Socket Programming
################################################################################

## TESTING ##
client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
# hardcoded host_ip value of the server that recieves the video packets
#host_ip = "10.14.25.26"
#host_ip = "10.9.169.204"
host_ip = "192.168.1.19"
# Arbitrary port number
port = 9999
# Connect the client socket to the server
client_socket.connect((host_ip, port))



##################
#      TEXT      #
##################
client_text_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
# hardcoded host_ip value of the server that recieves the video packets
#host_ip = "10.14.25.26"
#host_ip = "10.9.169.204"
host_ip = "192.168.1.19"
# Arbitrary port number
text_port = 9998
# Connect the client socket to the server
client_text_socket.connect((host_ip, text_port))
 



############################
#           SOUND          #
############################

client_sound_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sound_port = 9997
# Connect the client socket to the server
client_sound_socket.connect((host_ip, sound_port))

# SOUND COMUNITCATION SOCKET
client_sound_comm_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sound_comm_port = 9996
# Connect the client socket to the server
client_sound_comm_socket.connect((host_ip, sound_comm_port))


# TESTING
packet_payload = struct.calcsize("Q")
# TESTING




class Ui_MainWindow(QWidget):

    conversation_list = []
    client_name = socket.gethostname()
    audio,context = pyshine.audioCapture(mode="get")

    mute = False
    mute_button_name = "Muted"

    # Helps handled the emited signal
    def ImageUpdateSlot(self, Image):
        self.video_feed.setPixmap(QPixmap.fromImage(Image))

    def TextUpdateSlot(self, Text):
        if Text not in self.conversation_list:
            self.conversation_list.append(Text)
            # Handles putting text on the right pane
            self.textBrowser.append(f"{Text}\n")

    def SoundUpdateSlot(self, Sound):
        # [!?] Place in thread? Not playing music?
        #print(f"SOUND: {Sound}")
        pass
        # if not self.mute:
        #     self.audio.put(Sound)


    def StopFeed(self):
        self.video_thread.stop()

    def setupUi(self, MainWindow):
        #super(Ui_MainWindow, self).setupUi(MainWindow)
        self.v_layout = QVBoxLayout()

        # QLabel() is a widget that provides a text or image display--important for displaying video
        self.video_feed = QLabel()


        self.v_layout.addWidget(self.video_feed)

        self.CancelBTN = QPushButton("Cancel")
        self.CancelBTN.clicked.connect(self.StopFeed)

        self.v_layout.addWidget(self.CancelBTN)



        # Create an instance of a video thread to display the video so that it does not catch the MainWindow class in an infinite loop
        # Sends the video to the server
        self.video_thread = sendVideoThread()

        # Creates a thread to handle recieving data from the server
        self.receiveVideoThread = receiveVideoThread()
        self.receiveVideoThread.start()
         # Calls the Slot
        self.receiveVideoThread.updatedImage.connect(self.ImageUpdateSlot)


        # Starts the thread
        self.video_thread.start()
        

        self.setLayout(self.v_layout)

        MainWindow.setObjectName("Client")
        MainWindow.resize(848, 532)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.verticalLayout_2 = QtWidgets.QVBoxLayout(self.centralwidget)
        self.verticalLayout_2.setObjectName("verticalLayout_2")
        self.horizontalLayout_3 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_3.setObjectName("horizontalLayout_3")
        self.video_feed = QtWidgets.QLabel(self.centralwidget)
        self.video_feed.setMinimumSize(QtCore.QSize(600, 0))
        self.video_feed.setText("")
        self.video_feed.setObjectName("video_feed")
        self.horizontalLayout_3.addWidget(self.video_feed)
        self.textBrowser = QtWidgets.QTextBrowser(self.centralwidget)
        self.textBrowser.setObjectName("textBrowser")
        self.horizontalLayout_3.addWidget(self.textBrowser)

        
        # Handles put test on the right pane
        self.textBrowser.append("Messages")
        self.textBrowser.append("--------")


        self.verticalLayout_2.addLayout(self.horizontalLayout_3)
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.label = QtWidgets.QLabel(self.centralwidget)
        self.label.setObjectName("label")
        self.horizontalLayout.addWidget(self.label)
        self.lineEdit = QtWidgets.QLineEdit(self.centralwidget)
        self.lineEdit.setMinimumSize(QtCore.QSize(0, 75))
        self.lineEdit.setCursor(QtGui.QCursor(QtCore.Qt.IBeamCursor))
        self.lineEdit.setObjectName("lineEdit")
        self.horizontalLayout.addWidget(self.lineEdit)


        # # CODE TO GET THE TEXT INPUT IN THE LINEEDIT BOX
        # msg = self.lineEdit.text()

        self.verticalLayout = QtWidgets.QVBoxLayout()
        self.verticalLayout.setObjectName("verticalLayout")
        self.pushButton = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton.setObjectName("pushButton")
        self.verticalLayout.addWidget(self.pushButton)
        # Allow the push button to be the default button
        self.pushButton.setDefault(True)
        self.pushButton.setAutoDefault(True)

        # TEXT #

        # CODE TO CONTROL WHEN SEND BUTTON WAS CLICKED
        self.pushButton.clicked.connect(lambda: self.handleSendButton(f"{self.lineEdit.text()}"))
        
        # Allows enter to cal the pushButton
        self.lineEdit.returnPressed.connect(self.pushButton.click)


        # Creates a thread to handle recieving data from the server
        self.receiveTextThread = receiveTextThread()
        self.receiveTextThread.start()
        # Calls the Slot
        self.receiveTextThread.updatedText.connect(self.TextUpdateSlot)


        # SOUND # 

        # Creates a thread to handle recieving data from the server
        self.sendAudioThread = sendAudioThread()
        self.sendAudioThread.start()
         # Calls the Slot
        #self.sendAudioThread.updatedAudio.connect(self.SoundUpdateSlot)

        # Creates a thread to handle recieving data from the server
        self.receiveAudioThread = receiveAudioThread()
        self.receiveAudioThread.start()
        # Calls the Slot
        self.receiveAudioThread.updatedAudio.connect(self.SoundUpdateSlot)

        # Starts the thread
        #self.video_thread.start()


        self.pushButton_2 = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_2.setObjectName("pushButton_2")
        self.verticalLayout.addWidget(self.pushButton_2)


        # CODE TO CONTROL WHEN MUTE BUTTON WAS CLICKED
        self.pushButton_2.clicked.connect(self.handleMuteButton)


        self.horizontalLayout.addLayout(self.verticalLayout)
        self.verticalLayout_2.addLayout(self.horizontalLayout)
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 848, 21))
        self.menubar.setObjectName("menubar")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)


    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate(f"{socket.gethostbyname(socket.gethostname())}", f"{socket.gethostbyname(socket.gethostname())}"))
        self.label.setText(_translate(f"{socket.gethostbyname(socket.gethostname())}", "You:"))
        self.pushButton.setText(_translate(f"{socket.gethostbyname(socket.gethostname())}", "Send"))
        self.pushButton_2.setText(_translate(f"{socket.gethostbyname(socket.gethostname())}", "Unmute"))

    def handleSendButton(self, message):
        #print("SEND BUTTON CLICKED")
        # Pickle the image into a bytestring
        
        print(f"MESSAGE: {message}")
        text = f"{self.client_name}: {message}".encode('utf-8')
        #text = b"TEST DATA"
        # text = pickle.dumps(text)

        # text = struct.pack("Q", len(text)) + text
        client_text_socket.sendall(text)

        # Clear text in lineEdit
        self.lineEdit.setText("")
        self.lineEdit.clear()
    
    def handleMuteButton(self):
        self.mute = not self.mute
        print(f"MUTE: {self.mute}")

        self.sendAudioThread.updateMute()

        if self.mute:
            self.pushButton_2.setText("Mute")
        else:
            self.pushButton_2.setText("Unmute")

# A worker that handles the video
class sendVideoThread(QThread):
    # Creates a signal to later be emited in order to call the ImageUpdateSlot in the main window
    updatedImage = pyqtSignal(QImage)

    # Start the thread
    def run(self):
        # Used to shut off the thread
        self.ThreadActive = True
        # Uses the webcam
        Capture = cv2.VideoCapture(0)

        # # [SOCKET PROGRAMMING]
        # # Creates a client socket
        # client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        # # hardcoded host_ip value of the server that recieves the video packets
        # host_ip = "10.14.25.26"
        # ##host_ip = "10.9.169.204"
        # # Arbitrary port number
        # port = 9999
        # # Connect the client socket to the server
        # client_socket.connect((host_ip, port))

        

        while self.ThreadActive:
            # Returns a tuple of a return value, and and image (return, image)
            return_val, image = Capture.read()
            
            # If there was a returned value--no issue returning a frame
            if return_val:
                # Convert the frame into an RGB image
              #  image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
                # Flips the image on the vertical axis denoted by the "1"
              #  image = cv2.flip(image, 1)
              #  converted_image = QImage(image.data, image.shape[1], image.shape[0], QImage.Format_RGB888)
              #  image = converted_image.scaled(640, 480, Qt.KeepAspectRatio)

                # Sends a message to the main window class to be transmitted--stored in the Pic variable
              #  self.updatedImage.emit(image)
                
                # [ TEST ] Attempt to send image data to server
                

                # Resize the image 
                image = imutils.resize(image, width=320)

                # Pickle the image into a bytestring
                image = pickle.dumps(image)

                image = struct.pack("Q", len(image)) + image               

                client_socket.sendall(image)



    def stop(self):
        self.ThreadActive = False
        self.quit()




class receiveVideoThread(QThread):
    # Creates a signal to later be emited in order to call the ImageUpdateSlot in the main window
    updatedImage = pyqtSignal(QImage)
    
    packet_payload = struct.calcsize("Q")
    data = b""



    # Start the thread
    def run(self):
        # Used to shut off the thread
        #temp_sever_socket, temp_server_addr = recieving_socket.accept()
        threadActive = True

        # print("RUNNING THREAD")

        while threadActive:
            # print(f"in thread")
            # packet = temp_sever_socket.recv(4*1024)
            # print(f"PACKET: {packet}")



            while len(self.data) < self.packet_payload:
                # print(f"in data checking")

                packet = client_socket.recv(4*1024)
                if not packet: break
                self.data += packet
            packed_msg_size = self.data[:self.packet_payload]
            self.data = self.data[self.packet_payload:]
            msg_size = struct.unpack("Q", packed_msg_size)[0]
         #   print(f"msg_size: {msg_size}")

            while len(self.data) < msg_size:

                self.data += client_socket.recv(4*1024)
                #print("len(data): ", len(data), "msg_size: ", msg_size)
            frame_data = self.data[:msg_size]
            self.data  = self.data[msg_size:]
            #print(f"TYPECHECKING {type(frame_data)}")


            frame = pickle.loads(frame_data)
            #print(f"framelen: {len(frame)}")


            Image = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
            # Flips the image on the vertical axis denoted by the "1"
            FlippedImage = cv2.flip(Image, 1)
            ConvertToQtFormat = QImage(FlippedImage.data, FlippedImage.shape[1], FlippedImage.shape[0],QImage.Format_RGB888)
            Pic = ConvertToQtFormat.scaled(640, 480, Qt.KeepAspectRatio)

            self.updatedImage.emit(Pic)
            #cv2.imshow("DATA FROM SERVER", frame)
            
            # https://stackoverflow.com/questions/34966541/how-can-one-display-an-image-using-cv2-in-python
            key = cv2.waitKey(1) & 0xFF
            
            if key  == ord('q'):
                break



    def stop(self):
        self.ThreadActive = False
        self.quit()



class receiveTextThread(QThread):
    # Creates a signal to later be emited in order to call the ImageUpdateSlot in the main window
    updatedText = pyqtSignal(str)
    
    packet_payload = struct.calcsize("Q")
    data = b""

    conversation_list = []

    # Start the thread
    def run(self):
        # Used to shut off the thread
        threadActive = True


        while threadActive:
            # Turn bytes into string
            text = (client_text_socket.recv(4*1024)).decode()

            if text not in self.conversation_list:
                print(text)
                self.conversation_list.append(text)
                self.updatedText.emit(text)

    
    def stop(self):
        self.ThreadActive = False
        self.quit()



class sendAudioThread(QThread):
    #mutedSignal = pyqtSignal(bool)
    muted = True
    muted_msg = "True".encode('utf-8')


    def run(self):
        # Used to shut off the thread
        threadActive = True
        # Uses the audio recorder
        audio, context = pyshine.audioCapture(mode="send")
        while threadActive:
            frame = audio.get()
            # Get a frame of data from audio recorder
            print(f"MUTED?:  {self.muted}")
            print(f"MUTED?:  {self.muted_msg}")
            if not self.muted:
                
                print("[sendAudioThread]")
                # If there was a returned value--no issue returning a frame
                #if frame is not None:
                

                    # Resize the image 
                    #image = imutils.resize(image, width=320)

                    # Pickle the image into a bytestring
                frame = pickle.dumps(frame)

                frame = struct.pack("Q", len(frame)) + frame               

                client_sound_socket.sendall(frame)

                    #print(frame)


            #else:
                # True: The client is muted
                #muted_msg = "True".encode('utf-8')


    def updateMute(self):
        self.muted = not self.muted
        print(f"MUTE UPDATED: {self.muted}")
        if self.muted:
            self.muted_msg = "True".encode('utf-8')
        else:
            self.muted_msg = "False".encode('utf-8')
        client_sound_comm_socket.sendall(self.muted_msg)
        #1 is True: The client is muted
        # muted_msg = "1".encode('utf-8')
        # client_sound_socket.sendall(muted_msg)           
          




class receiveAudioThread(QThread):
    # Creates a signal to later be emited in order to call the SoundUpdateSlot in the main window
    updatedAudio = pyqtSignal(numpy.ndarray)
    
    packet_payload = struct.calcsize("Q")


    # Start the thread
    def run(self):
        # Used to shut off the thread
        threadActive = True
        audio,context = pyshine.audioCapture(mode="get")
        data = b""

        payload_size = struct.calcsize("Q")

        while threadActive:
            # Turn bytes into string
            #frame = (client_text_socket.recv(4*1024)).decode()
            if client_sound_socket:
            #print(frame)
            #print("[RECEIVE AUDIO THREAD]")
                while len(data) < payload_size:
                    packet = client_sound_socket.recv(4*1024) # 4K
                    if not packet: break
                    data+=packet
                packed_msg_size = data[:payload_size]
                data = data[payload_size:]
                msg_size = struct.unpack("Q",packed_msg_size)[0]
                
                while len(data) < msg_size:
                    data += client_sound_socket.recv(4*1024)
                frame_data = data[:msg_size]
                data  = data[msg_size:]
                #try:
                #if json.loads(frame_data.decode('utf-8')):
                frame = pickle.loads(frame_data)
              #  print(type(frame))
                #print(frame)
                #self.updatedAudio.emit(frame)

                audio.put(frame)
               # print("WORKS")
                #except:
                #    Exception



    


            # text = struct.unpack("Q", text)[0]
            # text = pickle.loads(text)

            #client_text_socket.sendall(text)

# class displayVideoThread(QThread):

# # Start the thread
#     def run(self):
#         # Used to shut off the thread
#         self.ThreadActive = True

#         while self.ThreadActive:
#             print("[display]")

#             frame = video_queue.get()
#             frame = pickle.loads(frame)

#             print(f"FRAME: {frame}")
#             #cv2.imshow("GOT BACK FROM SERVER", frame)




if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    #ui.__init__()
    MainWindow.show()

    sys.exit(app.exec_())

